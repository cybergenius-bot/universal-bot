# bot.py
# Production-ready Telegram –±–æ—Ç –Ω–∞ FastAPI (webhook) —Å:
# - Lifespan (–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è/–∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ) –∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º PTB Application
# - Secure webhook: X-Telegram-Bot-Api-Secret-Token (–∞–≤—Ç–æ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏)
# - Middleware correlation-id (graceful fallback), GZip, TrustedHost
# - –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –ë–î —á–µ—Ä–µ–∑ SQLAlchemy 2.0 (graceful fallback –Ω–∞ in-memory)
# - Rate limit, health-check, –±–∞–∑–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã, –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞

import os
import json
import time
import asyncio
import ipaddress
import logging
import secrets
import string
from contextlib import asynccontextmanager
from typing import Optional, List, Dict, Any
from collections import defaultdict, deque

from fastapi import FastAPI, Request, Response, HTTPException, status
from fastapi.middleware.gzip import GZipMiddleware
from starlette.middleware.trustedhost import TrustedHostMiddleware

# --- Correlation-ID middleware: –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, —Å graceful fallback ---
try:
    from asgi_correlation_id import CorrelationIdMiddleware, CorrelationIdFilter  # type: ignore
except Exception:
    class CorrelationIdMiddleware:  # no-op middleware
        def __init__(self, app, header_name: str = "X-Request-ID", *args, **kwargs):
            self.app = app
        async def __call__(self, scope, receive, send):
            await self.app(scope, receive, send)
    class CorrelationIdFilter(logging.Filter):
        def filter(self, record: logging.LogRecord) -> bool:
            if not hasattr(record, "correlation_id"):
                record.correlation_id = "-"
            return True

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–∫—Ä—É–∂–µ–Ω–∏—è ---
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "").strip()
WEBHOOK_URL = os.getenv("WEBHOOK_URL", "").strip()
# –ï—Å–ª–∏ –Ω–µ –∑–∞–¥–∞–Ω, —Å–µ–∫—Ä–µ—Ç –±—É–¥–µ—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –Ω–∞ —Å—Ç–∞—Ä—Ç–µ –∏ —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ CURRENT_WEBHOOK_SECRET
TELEGRAM_WEBHOOK_SECRET_ENV = os.getenv("TELEGRAM_WEBHOOK_SECRET", "").strip()  # 1..256, A-Z a-z 0-9 _ -

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite+aiosqlite:///./bot.db")
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()
ALLOWED_HOSTS = os.getenv("ALLOWED_HOSTS", "*")
TELEGRAM_ALLOWED_UPDATES = os.getenv("TELEGRAM_ALLOWED_UPDATES", "message,callback_query")
TELEGRAM_DROP_PENDING_UPDATES = os.getenv("TELEGRAM_DROP_PENDING_UPDATES", "true").lower() == "true"
TELEGRAM_MAX_CONNECTIONS = int(os.getenv("TELEGRAM_MAX_CONNECTIONS", "40"))
ENABLE_IP_ALLOWLIST = os.getenv("ENABLE_IP_ALLOWLIST", "false").lower() == "true"
TELEGRAM_IP_RANGES = os.getenv("TELEGRAM_IP_RANGES", "")  # "149.154.160.0/20,91.108.4.0/22"
CORRELATION_ID_HEADER = os.getenv("CORRELATION_ID_HEADER", "X-Request-ID")
MAX_TELEGRAM_PAYLOAD_BYTES = int(os.getenv("MAX_TELEGRAM_PAYLOAD_BYTES", "1048576"))

# --- –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ + —Ñ–∏–ª—å—Ç—Ä –¥–ª—è correlation_id ---
logging.basicConfig(
    level=getattr(logging, LOG_LEVEL, logging.INFO),
    format="%(asctime)s %(levelname)s [%(name)s] [%(correlation_id)s] %(message)s",
)
for _h in logging.getLogger().handlers:
    _h.addFilter(CorrelationIdFilter())
logger = logging.getLogger("bot")

# --- Telegram: PTB Application –∏ Handlers ---
from telegram import Update, Bot, BotCommand
from telegram.ext import (
    Application,
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    ContextTypes,
    filters,
)

application: Optional[Application] = None  # PTB Application
bot: Optional[Bot] = None  # Telegram Bot

# –¢–µ–∫—É—â–∏–π —Å–µ–∫—Ä–µ—Ç –≤–µ–±—Ö—É–∫–∞ (–∏–∑ env –∏–ª–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –Ω–∞ —Å—Ç–∞—Ä—Ç–µ)
CURRENT_WEBHOOK_SECRET: Optional[str] = None

def _generate_secret(length: int = 32) -> str:
    # –†–∞–∑—Ä–µ—à—ë–Ω–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –ø–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º Telegram (A-Z a-z 0-9 _ -)
    alphabet = string.ascii_letters + string.digits + "_-"
    return "".join(secrets.choice(alphabet) for _ in range(length))

# --- SQLAlchemy (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ), fallback –Ω–∞ in-memory –µ—Å–ª–∏ –º–æ–¥—É–ª—è –Ω–µ—Ç ---
try:
    from sqlalchemy import String, Integer, BigInteger, Text, DateTime, func, select, text
    from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column
    from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession

    SQLA_AVAILABLE = True

    class Base(DeclarativeBase):
        pass

    class User(Base):
        __tablename__ = "users"
        id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
        tg_user_id: Mapped[int] = mapped_column(BigInteger, index=True, unique=True)
        username: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
        first_name: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
        last_name: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
        created_at: Mapped[Any] = mapped_column(DateTime(timezone=True), server_default=func.now())
        updated_at: Mapped[Any] = mapped_column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

    class MessageLog(Base):
        __tablename__ = "message_logs"
        id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
        tg_user_id: Mapped[int] = mapped_column(BigInteger, index=True)
        chat_id: Mapped[int] = mapped_column(BigInteger, index=True)
        message_id: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
        text: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
        created_at: Mapped[Any] = mapped_column(DateTime(timezone=True), server_default=func.now())

    engine = create_async_engine(DATABASE_URL, echo=False, pool_pre_ping=True)
    SessionLocal = async_sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)

    async def upsert_user(session: AsyncSession, tg_user) -> None:
        result = await session.execute(select(User).where(User.tg_user_id == tg_user.id))
        user = result.scalar_one_or_none()
        if user is None:
            user = User(
                tg_user_id=tg_user.id,
                username=tg_user.username,
                first_name=tg_user.first_name,
                last_name=tg_user.last_name,
            )
            session.add(user)
        else:
            user.username = tg_user.username
            user.first_name = tg_user.first_name
            user.last_name = tg_user.last_name
        await session.commit()

    async def log_message(session: AsyncSession, tg_user_id: int, chat_id: int, msg_id: Optional[int], text_val: Optional[str]) -> None:
        entry = MessageLog(tg_user_id=tg_user_id, chat_id=chat_id, message_id=msg_id, text=text_val)
        session.add(entry)
        await session.commit()

    async def count_users(session: AsyncSession) -> int:
        res = await session.execute(select(func.count()).select_from(User))
        return int(res.scalar_one() or 0)

    async def count_messages(session: AsyncSession) -> int:
        res = await session.execute(select(func.count()).select_from(MessageLog))
        return int(res.scalar_one() or 0)

except Exception:
    # Fallback: in-memory
    SQLA_AVAILABLE = False
    _users: Dict[int, Dict[str, Any]] = {}
    _messages: List[Dict[str, Any]] = []
    _lock = asyncio.Lock()

    async def upsert_user(session, tg_user) -> None:
        async with _lock:
            _users[tg_user.id] = {
                "tg_user_id": tg_user.id,
                "username": tg_user.username,
                "first_name": tg_user.first_name,
                "last_name": tg_user.last_name,
            }

    async def log_message(session, tg_user_id: int, chat_id: int, msg_id: Optional[int], text_val: Optional[str]) -> None:
        async with _lock:
            _messages.append(
                {
                    "tg_user_id": tg_user_id,
                    "chat_id": chat_id,
                    "message_id": msg_id,
                    "text": text_val,
                    "created_at": time.time(),
                }
            )

    async def count_users(session=None) -> int:
        return len(_users)

    async def count_messages(session=None) -> int:
        return len(_messages)

# --- –ü—Ä–æ—Å—Ç–∞—è –∞–Ω—Ç–∏—Å–ø–∞–º/Rate Limit –ª–æ–≥–∏–∫–∞ (in-memory) ---
RATE_LIMIT_WINDOW_SEC = 3
RATE_LIMIT_MAX_MESSAGES = 8
_user_messages_window: Dict[int, deque] = defaultdict(lambda: deque(maxlen=RATE_LIMIT_MAX_MESSAGES))

# --- Handlers ---
async def start_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message:
        return
    if SQLA_AVAILABLE:
        async with SessionLocal() as session:
            await upsert_user(session, update.effective_user)
            await log_message(session, update.effective_user.id, update.effective_chat.id, update.message.message_id, "/start")
    else:
        await upsert_user(None, update.effective_user)
        await log_message(None, update.effective_user.id, update.effective_chat.id, update.message.message_id, "/start")

    await update.message.reply_text(
        f"–ü—Ä–∏–≤–µ—Ç, {update.effective_user.first_name or '–¥—Ä—É–≥'}! üëã\n–ù–∞–±–µ—Ä–∏—Ç–µ /help –¥–ª—è —Å–ø–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥."
    )

async def help_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message:
        return
    if SQLA_AVAILABLE:
        async with SessionLocal() as session:
            await log_message(session, update.effective_user.id, update.effective_chat.id, update.message.message_id, "/help")
    else:
        await log_message(None, update.effective_user.id, update.effective_chat.id, update.message.message_id, "/help")

    await update.message.reply_text(
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "/start ‚Äî –Ω–∞—á–∞—Ç—å\n"
        "/help ‚Äî –ø–æ–º–æ—â—å\n"
        "/status ‚Äî —Å—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–∏—Å–∞\n"
        "/stats ‚Äî –±–∞–∑–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n"
    )

async def status_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message:
        return
    if SQLA_AVAILABLE:
        async with SessionLocal() as session:
            await log_message(session, update.effective_user.id, update.effective_chat.id, update.message.message_id, "/status")
    else:
        await log_message(None, update.effective_user.id, update.effective_chat.id, update.message.message_id, "/status")

    await update.message.reply_text("‚úÖ –ë–æ—Ç –∏ API —Ä–∞–±–æ—Ç–∞—é—Ç —à—Ç–∞—Ç–Ω–æ.")

async def stats_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message:
        return
    if SQLA_AVAILABLE:
        async with SessionLocal() as session:
            users_cnt = await count_users(session)
            msgs_cnt = await count_messages(session)
            await log_message(session, update.effective_user.id, update.effective_chat.id, update.message.message_id, "/stats")
        await update.message.reply_text(f"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π {users_cnt}, —Å–æ–æ–±—â–µ–Ω–∏–π {msgs_cnt}")
    else:
        await log_message(None, update.effective_user.id, update.effective_chat.id, update.message.message_id, "/stats")
        await update.message.reply_text(f"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ (in-memory): –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π ~{await count_users()}, —Å–æ–æ–±—â–µ–Ω–∏–π ~{await count_messages()}")

async def text_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.message.text:
        return
    uid = update.effective_user.id
    now = time.time()
    window = _user_messages_window[uid]
    window.append(now)
    while window and now - window[0] > RATE_LIMIT_WINDOW_SEC:
        window.popleft()
    if len(window) >= RATE_LIMIT_MAX_MESSAGES:
        return

    text_val = update.message.text
    if SQLA_AVAILABLE:
        async with SessionLocal() as session:
            await upsert_user(session, update.effective_user)
            await log_message(session, update.effective_user.id, update.effective_chat.id, update.message.message_id, text_val)
    else:
        await upsert_user(None, update.effective_user)
        await log_message(None, update.effective_user.id, update.effective_chat.id, update.message.message_id, text_val)

    lower = text_val.lower()
    if "–ø—Ä–∏–≤–µ—Ç" in lower:
        await update.message.reply_text(f"–ü—Ä–∏–≤–µ—Ç, {update.effective_user.first_name or ''}! üòä")
    elif "–∫–∞–∫ –¥–µ–ª–∞" in lower:
        await update.message.reply_text("–£ –º–µ–Ω—è –æ—Ç–ª–∏—á–Ω–æ! –ê —É —Ç–µ–±—è?")
    else:
        await update.message.reply_text("–Ø –ø–æ–ª—É—á–∏–ª —Ç–≤–æ—ë —Å–æ–æ–±—â–µ–Ω–∏–µ. –û—Ç–ø—Ä–∞–≤—å /help –¥–ª—è —Å–ø–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥.")

async def error_handler(update: Optional[Update], context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.error("PTB error: %s", repr(context.error), exc_info=True)

def build_ptb_application(token: str) -> Application:
    app = (
        ApplicationBuilder()
        .token(token)
        .concurrent_updates(True)
        .build()
    )
    app.add_handler(CommandHandler("start", start_cmd))
    app.add_handler(CommandHandler("help", help_cmd))
    app.add_handler(CommandHandler("status", status_cmd))
    app.add_handler(CommandHandler("stats", stats_cmd))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, text_handler))
    app.add_error_handler(error_handler)
    return app

# --- –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å webhook ---
TELEGRAM_SECRET_HEADER = "X-Telegram-Bot-Api-Secret-Token"

def verify_secret_token(req: Request) -> None:
    recv = req.headers.get(TELEGRAM_SECRET_HEADER)
    expected = CURRENT_WEBHOOK_SECRET
    if not expected:
        # –ï—Å–ª–∏ —Å–µ–∫—Ä–µ—Ç –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω (–Ω–µ –¥–æ–ª–∂–Ω–æ —Å–ª—É—á–∞—Ç—å—Å—è –ø–æ—Å–ª–µ —Å—Ç–∞—Ä—Ç–∞), –ø—Ä–æ–ø—É—Å—Ç–∏–º, –Ω–æ –∑–∞–ª–æ–≥–∏—Ä—É–µ–º
        logger.warning("Webhook secret not initialized at verification step")
        return
    if recv != expected:
        logger.warning("Invalid webhook secret token")
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid webhook secret")

def ip_in_ranges(ip: str, cidrs: List[str]) -> bool:
    try:
        ip_addr = ipaddress.ip_address(ip)
    except Exception:
        return False
    for cidr in cidrs:
        try:
            if ip_addr in ipaddress.ip_network(cidr.strip()):
                return True
        except Exception:
            continue
    return False

def verify_ip_allow<span class="cursor">‚ñà</span>
