# bot.py ‚Äî UNIVERSAL GPT‚Äë4o ‚Äî HOTFIX#7b‚ÄëU9
# U9:
# 1) –°–∞–Ω–∏—Ç–∞–π–∑–µ—Ä –µ—â—ë –∂—ë—Å—Ç—á–µ: —Å–Ω–æ—Å–∏—Ç ###, –∂–∏—Ä/–∫—É—Ä—Å–∏–≤, –º–∞—Ä–∫–µ—Ä—ã —Å–ø–∏—Å–∫–æ–≤ (- + ‚Ä¢ ‚ñ∫ ‚óè ‚ñ™ ‚ñ´ ‚óÜ ‚óá ‚òÖ ‚òÜ, –∞ —Ç–∞–∫–∂–µ ‚Äî –∏ ‚Äì –≤ –Ω–∞—á–∞–ª–µ —Å—Ç—Ä–æ–∫–∏), code-fence, blockquote '>'
# 2) –≠–º–æ–¥–∑–∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º; –Ω—É–º–µ—Ä–∞—Ü–∏—è 1., 2., 3. —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è
# 3) parse_mode=None, –≤—Å–µ –æ—Ç–≤–µ—Ç—ã —á–µ—Ä–µ–∑ send_clean(...)
# 4) –ê–≤—Ç–æ—è–∑—ã–∫ RU/HE ‚Äî —Å—Ä–∞–∑—É; EN ‚Äî —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –∫–æ—Ä–æ—Ç—ã—à (<12 —Å–∏–º–≤–æ–ª–æ–≤)
# 5) –°—Ç–æ—Ä–∏—Å/—Ä–∞—Å—Å–∫–∞–∑ ‚Äî —Ç–æ–ª—å–∫–æ –ø–æ —è–≤–Ω–æ–π –ø—Ä–æ—Å—å–±–µ, –±–µ–∑ Markdown

import os
import re
import time
from collections import deque, defaultdict
from typing import Deque, Dict, Optional

from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import PlainTextResponse, JSONResponse

from aiogram import Bot, Dispatcher, Router, F
from aiogram.types import (
    Message, Update, CallbackQuery,
    ReplyKeyboardMarkup, KeyboardButton,
    InlineKeyboardMarkup, InlineKeyboardButton,
    BotCommand, BotCommandScopeDefault
)
from aiogram.filters import Command, CommandStart

# =========================
# Env
# =========================
TELEGRAM_BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN", "")
BASE_URL = os.environ.get("BASE_URL", "")
WEBHOOK_SECRET = os.environ.get("WEBHOOK_SECRET", "railway123-secret")
WEBHOOK_PATH = "/telegram/railway123"
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY", "")
OPENAI_MODEL = os.environ.get("OPENAI_MODEL", "gpt-4o-mini")  # "gpt-4o" –¥–ª—è –º–∞–∫—Å. –∫–∞—á–µ—Å—Ç–≤–∞

# =========================
# OpenAI
# =========================
_openai_client = None
def get_openai_client():
    global _openai_client
    if _openai_client is None:
        try:
            from openai import OpenAI
            _openai_client = OpenAI(api_key=OPENAI_API_KEY)
        except Exception:
            _openai_client = None
    return _openai_client

async def ask_openai(prompt: str, system: Optional[str] = None, temperature: float = 0.7, model: Optional[str] = None) -> str:
    client = get_openai_client()
    if not client:
        return "–ü–æ–∫–∞ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ GPT‚Äë4o. –ü–æ–¥–∫–ª—é—á–∏—Ç–µ OPENAI_API_KEY –∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ."
    msgs = []
    if system:
        msgs.append({"role": "system", "content": system})
    msgs.append({"role": "user", "content": prompt})
    use_model = model or OPENAI_MODEL
    try:
        resp = client.chat.completions.create(model=use_model, messages=msgs, temperature=temperature)
        return resp.choices[0].message.content.strip()
    except Exception as e:
        return f"–ù–µ —Å–º–æ–≥ –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç –æ—Ç –º–æ–¥–µ–ª–∏ ({type(e).__name__}): {e}"

# =========================
# App/Bot/DP
# =========================
app = FastAPI()
bot = Bot(token=TELEGRAM_BOT_TOKEN, parse_mode=None)  # –æ—Ç–∫–ª—é—á–∞–µ–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ Telegram
dp = Dispatcher()
router = Router()
dp.include_router(router)

# =========================
# UI
# =========================
def make_reply_menu_button(ui_lang: str = "ru"):
    text = {"ru": "–ú–µ–Ω—é", "en": "Menu", "he": "◊™◊§◊®◊ô◊ò"}.get(ui_lang, "–ú–µ–Ω—é")
    return ReplyKeyboardMarkup(
        resize_keyboard=True,
        keyboard=[[KeyboardButton(text=text)]],
        input_field_placeholder={"ru": "–ù–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ‚Ä¶", "en": "Type a message‚Ä¶", "he": "◊î◊ß◊ú◊ì/◊ô ◊î◊ï◊ì◊¢◊î‚Ä¶"}
            .get(ui_lang, "–ù–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ‚Ä¶"),
        selective=True
    )

def make_inline_menu(ui_lang: str = "ru"):
    t = {
        "help": {"ru": "–ü–æ–º–æ—â—å", "en": "Help", "he": "◊¢◊ñ◊®◊î"},
        "pay": {"ru": "–û–ø–ª–∞—Ç–∏—Ç—å", "en": "Pay", "he": "◊™◊©◊ú◊ï◊ù"},
        "refs": {"ru": "–†–µ—Ñ–µ—Ä–∞–ª—ã", "en": "Referrals", "he": "◊î◊§◊†◊ô◊ï◊™"},
        "profile": {"ru": "–ü—Ä–æ—Ñ–∏–ª—å", "en": "Profile", "he": "◊§◊®◊ï◊§◊ô◊ú"},
        "lang": {"ru": "–°–º–µ–Ω–∏—Ç—å —è–∑—ã–∫", "en": "Change language", "he": "◊©◊†◊î ◊©◊§◊î"},
        "mode": {"ru": "–†–µ–∂–∏–º –æ—Ç–≤–µ—Ç–∞", "en": "Reply mode", "he": "◊û◊¶◊ë ◊™◊í◊ï◊ë◊î"},
        "tts": {"ru": "–û–∑–≤—É—á–∏—Ç—å (TTS)", "en": "Speak (TTS)", "he": "◊î◊û◊®◊î ◊ú◊ì◊ô◊ë◊ï◊®"},
        "asr": {"ru": "–ü–æ–∫–∞–∑–∞—Ç—å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫—É", "en": "Show transcript", "he": "◊î◊¶◊í ◊™◊û◊ú◊ô◊ú"},
        "close": {"ru": "–°–∫—Ä—ã—Ç—å", "en": "Close", "he": "◊°◊í◊ï◊®"},
    }
    def _(k): return t[k].get(ui_lang, t[k]["ru"])
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=_("help"), callback_data="help"),
         InlineKeyboardButton(text=_("pay"), callback_data="pay")],
        [InlineKeyboardButton(text=_("refs"), callback_data="refs"),
         InlineKeyboardButton(text=_("profile"), callback_data="profile")],
        [InlineKeyboardButton(text=_("lang"), callback_data="lang"),
         InlineKeyboardButton(text=_("mode"), callback_data="mode")],
        [InlineKeyboardButton(text=_("tts"), callback_data="tts"),
         InlineKeyboardButton(text=_("asr"), callback_data="asr")],
        [InlineKeyboardButton(text=_("close"), callback_data="close_menu")],
    ])

# =========================
# Language policy
# =========================
UserId = int
user_ui_lang: Dict[UserId, str] = defaultdict(lambda: "ru")
user_lang_hist: Dict[UserId, Deque[str]] = defaultdict(lambda: deque(maxlen=3))

def detect_script_lang(text: str) -> Optional[str]:
    heb = sum('\u0590' <= ch <= '\u05FF' for ch in text)     # Hebrew
    cyr = sum('–ê' <= ch <= '—è' or ch in "—ë–Å" for ch in text)  # Cyrillic
    lat = sum('A' <= ch <= 'z' for ch in text)                # Latin
    if heb > cyr and heb > lat and heb > 0: return "he"
    if cyr > lat and cyr > heb and cyr > 0: return "ru"
    if lat > cyr and lat > heb and lat > 0: return "en"
    return None

def choose_content_lang(user_id: int, text: str) -> str:
    t = (text or "").strip()
    det = detect_script_lang(t)
    # EN ‚Äî –Ω–µ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ –∫–æ—Ä–æ—Ç—ã—à–∞—Ö; RU/HE ‚Äî –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –º–≥–Ω–æ–≤–µ–Ω–Ω–æ
    if det == "en" and len(t) < 12:
        det = None
    if det in ("ru", "he"):
        lang = det
    elif det == "en":
        lang = "en"
    else:
        hist = user_lang_hist[user_id]
        if len(hist) >= 2:
            for l in ("ru", "en", "he"):
                if sum(1 for x in hist if x == l) >= 2:
                    return l
        lang = user_ui_lang[user_id]
    # –æ–±–Ω–æ–≤–∏–º –≥–∏—Å—Ç–µ—Ä–µ–∑–∏—Å
    hist = user_lang_hist[user_id]
    hist.append(lang)
    for l in ("ru", "en", "he"):
        if sum(1 for x in hist if x == l) >= 2:
            return l
    return lang

# =========================
# Anti-echo (voice)
# =========================
recent_voice_meta: Dict[UserId, Dict[str, float]] = defaultdict(dict)
def anti_echo_reply(ui_lang: str = "ru"):
    heads = {"ru": ("–ö—Ä–∞—Ç–∫–æ", "–î–µ—Ç–∞–ª–∏", "–ß–µ–∫‚Äë–ª–∏—Å—Ç"),
             "en": ("Brief", "Details", "Checklist"),
             "he": ("◊™◊û◊¶◊ô◊™", "◊§◊®◊ò◊ô◊ù", "◊¶◊≥◊ß‚Äë◊ú◊ô◊°◊ò")}
    h = heads.get(ui_lang, heads["ru"])
    return (
        f"{h[0]}: –Ø —É—Å–ª—ã—à–∞–ª(–∞) –≤–∞—à –≥–æ–ª–æ—Å –∏ –ø–æ–Ω—è–ª(–∞) –∑–∞–¥–∞—á—É. –°—Ñ–æ—Ä–º—É–ª–∏—Ä—É—é –æ—Ç–≤–µ—Ç –±–µ–∑ –ø–æ–≤—Ç–æ—Ä–∞ –≤–∞—à–µ–π —Ä–µ—á–∏.\n\n"
        f"{h[1]}: –û–ø–∏—à—É –ø–æ–¥—Ö–æ–¥, –ø—Ä–µ–¥–ª–æ–∂—É –≤–∞—Ä–∏–∞–Ω—Ç—ã –∏ –ø–æ–¥–≤–æ–¥–Ω—ã–µ –∫–∞–º–Ω–∏. –ï—Å–ª–∏ –Ω—É–∂–Ω–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ ‚Äî –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ.\n\n"
        f"{h[2]}:\n‚Äî 1) –¶–µ–ª—å ‚Üí 2) –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è ‚Üí 3) –û–ø—Ü–∏–∏ ‚Üí 4) –†–∏—Å–∫–∏ ‚Üí 5) –°–ª–µ–¥—É—é—â–∏–π —à–∞–≥.\n\n"
        f"–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫—É –ø–æ–∫–∞–∂—É —Ç–æ–ª—å–∫–æ –ø–æ –∫–Ω–æ–ø–∫–µ."
    )

# =========================
# Sanitize: —É–±–∏—Ä–∞–µ–º Markdown/¬´–∑–≤—ë–∑–¥–æ—á–∫–∏¬ª/–º–∞—Ä–∫–µ—Ä—ã, —Å–æ—Ö—Ä–∞–Ω—è–µ–º —ç–º–æ–¥–∑–∏ –∏ –Ω—É–º–µ—Ä–∞—Ü–∏—é
# =========================
# ¬´–∑–≤—ë–∑–¥–æ—á–∫–∏¬ª-–∞–Ω–∞–ª–æ–≥–∏ (–Ω–µ –∑–∞—Ç—Ä–∞–≥–∏–≤–∞–µ–º —ç–º–æ–¥–∑–∏ ‚ú® üîÆ –∏ –¥—Ä.)
ASTERISK_LIKE = r"\*\u2217\u2731\u204E\uFE61\uFF0A"  # * ‚àó ‚ú± ‚Åé Ôπ° Ôºä
# –º–∞—Ä–∫–µ—Ä—ã —Å–ø–∏—Å–∫–æ–≤ –≤ –Ω–∞—á–∞–ª–µ —Å—Ç—Ä–æ–∫–∏, –≤–∫–ª—é—á–∞—è —Ç–∏—Ä–µ: - + ‚Ä¢ ‚ñ∫ ‚ñ™ ‚ñ´ ‚óè ‚óã ‚óÜ ‚óá –∏ —Ç–∞–∫–∂–µ ‚Äî, ‚Äì
BULLET_START = r"\-\+\‚Ä¢\‚ñ∫\‚ñ™\‚ñ´\‚óè\‚óã\‚óÜ\‚óá"
HEADER_PAT = re.compile(r'^\s*#{1,6}\s*')
BLOCKQUOTE_PAT = re.compile(r'^\s*>\s+')
DASH_BULLET_PAT = re.compile(r'^\s*[‚Äì‚Äî]\s+')

META_PATTERNS = [
    re.compile(r'^\s*–∫–æ–Ω–µ—á–Ω–æ[,.! ]', re.IGNORECASE),
    re.compile(r'^\s*–¥–∞–≤–∞–π—Ç–µ[,.! ]', re.IGNORECASE),
    re.compile(r'^\s*—Å —É–¥–æ–≤–æ–ª—å—Å—Ç–≤–∏–µ–º[,.! ]', re.IGNORECASE),
    re.compile(r'^\s*–≤–æ—Ç –∫–∞–∫ (?:–º–æ–∂–Ω–æ|–º—ã)\b', re.IGNORECASE),
    re.compile(r'^\s*–ø—Ä–µ–¥–ª–∞–≥–∞—é\b', re.IGNORECASE),
]

def strip_markdown_line_start(ln: str) -> str:
    s = ln.strip()
    # code‚Äëfence
    if s.startswith("```"):
        return ""
    # blockquote '>'
    ln = BLOCKQUOTE_PAT.sub("", ln)
    # ### –∑–∞–≥–æ–ª–æ–≤–∫–∏
    ln = HEADER_PAT.sub("", ln)
    # –º–∞—Ä–∫–µ—Ä—ã —Å–ø–∏—Å–∫–æ–≤ –≤ –Ω–∞—á–∞–ª–µ —Å—Ç—Ä–æ–∫–∏
    ln = re.sub(rf'^\s*([{BULLET_START}])\s+', '', ln)
    # —Ç–∏—Ä–µ-–±—É–ª–ª–µ—Ç—ã ‚Äî –∏ ‚Äì
    ln = DASH_BULLET_PAT.sub("", ln)
    return ln

def sanitize_output(text: str) -> str:
    if not text:
        return text
    # 1) –ü–æ—Å—Ç—Ä–æ—á–Ω–∞—è —á–∏—Å—Ç–∫–∞
    lines = [strip_markdown_line_start(ln) for ln in text.splitlines()]
    text = "\n".join(ln for ln in lines if ln is not None)

    # 2) –ñ–∏—Ä/–∫—É—Ä—Å–∏–≤ Markdown: **..**, __..__, *..*, _.._
    text = re.sub(r'\*\*(.*?)\*\*', r'\1', text, flags=re.S)
    text = re.sub(r'__(.*?)__', r'\1', text, flags=re.S)
    text = re.sub(r'(?<!\S)\*(.+?)\*(?!\S)', r'\1', text, flags=re.S)
    text = re.sub(r'(?<!\S)_(.+?)_(?!\S)', r'\1', text, flags=re.S)

    # 3) –õ—é–±—ã–µ –æ–¥–∏–Ω–æ—á–Ω—ã–µ ¬´–∑–≤—ë–∑–¥–æ—á–∫–∏¬ª-—Å–∏–º–≤–æ–ª—ã –∏ –æ–±—Ä–∞—Ç–Ω—ã–µ –∞–ø–æ—Å—Ç—Ä–æ—Ñ—ã
    text = re.sub(rf'[{ASTERISK_LIKE}`]+', '', text)

    # 4) –°—Ç–∞—Ä—Ç–æ–≤—ã–µ –º–µ—Ç–∞‚Äë—Ñ—Ä–∞–∑—ã (–ö–æ–Ω–µ—á–Ω–æ‚Ä¶, –î–∞–≤–∞–π—Ç–µ‚Ä¶)
    text = text.strip()
    ls = text.splitlines()
    while ls:
        head = ls[0].strip()
        if any(p.match(head) for p in META_PATTERNS):
            ls.pop(0)
        else:
            break
    text = "\n".join(ls).strip()

    # 5) –°–∂–∏–º–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏ –ø—Ä–æ–±–µ–ª—ã
    text = re.sub(r'\n{3,}', '\n\n', text)
    text = re.sub(r'[ \t]{2,}', ' ', text)
    return text

async def send_clean(msg_or_chat, text: str, **kwargs):
    return await msg_or_chat.answer(sanitize_output(text), **kwargs)

# =========================
# System prompts
# =========================
def system_prompt_for(lang: str) -> str:
    if lang == "ru":
        return "–¢—ã SmartPro 24/7. –û—Ç–≤–µ—á–∞–π —Å—Ç—Ä–æ–≥–æ –Ω–∞ —Ä—É—Å—Å–∫–æ–º. –ë–µ–∑ Markdown/–∂–∏—Ä–Ω–æ–≥–æ/–∫—É—Ä—Å–∏–≤–∞/—Å–ø–∏—Å–∫–æ–≤. –û–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç. –≠–º–æ–¥–∑–∏ –º–æ–∂–Ω–æ."
    if lang == "he":
        return "◊ê◊™/◊î SmartPro 24/7. ◊¢◊†◊î/◊¢◊†◊ô ◊ê◊ö ◊ï◊®◊ß ◊ë◊¢◊ë◊®◊ô◊™. ◊ë◊ú◊ô Markdown/◊î◊ì◊í◊©◊ï◊™/◊®◊©◊ô◊û◊ï◊™. ◊ò◊ß◊°◊ò ◊§◊©◊ï◊ò. ◊ê◊û◊ï◊í◊≥◊ô ◊û◊ï◊™◊®."
    return "You are SmartPro 24/7. Answer strictly in English. No Markdown/bold/italics/lists. Plain text. Emojis allowed."

def copy_system_prompt_for(lang: str) -> str:
    if lang == "ru":
        return "–¢—ã –∫–æ–ø–∏—Ä–∞–π—Ç–µ—Ä. 1‚Äë–µ –ª–∏—Ü–æ, —Ç—ë–ø–ª—ã–π —Ç–æ–Ω. –ë–µ–∑ Markdown/–∑–≤—ë–∑–¥–æ—á–µ–∫/—Å–ø–∏—Å–∫–æ–≤/–∑–∞–≥–æ–ª–æ–≤–∫–æ–≤. 2‚Äì4 –∫–æ—Ä–æ—Ç–∫–∏—Ö –∞–±–∑–∞—Ü–∞."
    if lang == "he":
        return "◊ê◊™/◊î ◊ß◊ï◊§◊ô◊®◊ô◊ô◊ò◊®/◊ô◊™. ◊í◊ï◊£ ◊®◊ê◊©◊ï◊ü, ◊ò◊ï◊ü ◊ó◊ù. ◊ë◊ú◊ô Markdown/◊õ◊ï◊õ◊ë◊ô◊ï◊™/◊®◊©◊ô◊û◊ï◊™/◊õ◊ï◊™◊®◊ï◊™. 2‚Äì4 ◊§◊°◊ß◊ê◊ï◊™ ◊ß◊¶◊®◊ï◊™."
    return "Experienced copywriter. First person, warm tone. No Markdown/asterisks/lists/headings. 2‚Äì4 short paragraphs."

def build_user_prompt(lang: str, user_text: str) -> str:
    if lang == "ru":
        return f"–ó–∞–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {user_text}\n–î–∞–π —Ç–æ—á–Ω—ã–π, –Ω–µ–±–∞–Ω–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –ø–æ —Ç–µ–º–µ. –ë–µ–∑ Markdown/–∂–∏—Ä–Ω–æ–≥–æ/–∫—É—Ä—Å–∏–≤–∞/—Å–ø–∏—Å–∫–æ–≤."
    if lang == "he":
        return f"◊ë◊ß◊©◊™ ◊î◊û◊©◊™◊û◊©: {user_text}\n◊¢◊†◊î/◊¢◊†◊ô ◊™◊©◊ï◊ë◊î ◊û◊ì◊ï◊ô◊ß◊™ ◊ï◊ô◊©◊ô◊®◊î ◊ë◊†◊ï◊©◊ê. ◊ë◊ú◊ô Markdown/◊î◊ì◊í◊©◊ï◊™/◊®◊©◊ô◊û◊ï◊™."
    return f"User request: {user_text}\nProvide a precise, non‚Äëgeneric answer. No Markdown/bold/italics/lists."

# =========================
# Triggers (explicit creative only, tolerant)
# =========================
STORY_TRIG = re.compile(r'^\s*(–Ω–∞–ø–∏—à–∏|—Å–¥–µ–ª–∞–π|—Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π)\b.*\b(—Å—Ç–æ—Ä–∏—Å|story|–∏–Ω—Å—Ç–∞-?—Å—Ç–æ—Ä–∏—Å)\b', re.IGNORECASE | re.S)
NARR_TRIG  = re.compile(r'^\s*(–Ω–∞–ø–∏—à–∏|—Å–¥–µ–ª–∞–π|—Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π)\b.*\b(—Ä–∞—Å—Å–∫–∞–∑|—ç—Å—Å–µ|—Å–æ—á–∏–Ω–µ–Ω–∏–µ|–ø–æ–≤–µ—Å—Ç—å|short\s+story|essay)\b', re.IGNORECASE | re.S)
COPY_TRIG  = re.compile(r'(–ø–æ—Å—Ç\s+–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤|–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏[–µ—è]\b|–æ–ø–∏—Å–∞–Ω–∏[–µ—è]\b|–±–∏–æ\b|bio\b)', re.IGNORECASE)

def extract_topic_after_keyword(txt: str, keywords: list[str]) -> str:
    pattern = re.compile(r'(' + '|'.join(map(re.escape, keywords)) + r')\b', re.IGNORECASE)
    m = pattern.search(txt)
    tail = txt[m.end():] if m else txt
    tail = re.sub(r'^\s*(–ø—Ä–æ|–æ|about)\b', '', tail, flags=re.IGNORECASE).strip()
    return tail if tail else txt.strip()

# =========================
# Commands
# =========================
async def set_commands():
    await bot.set_my_commands(
        [BotCommand(command="start", description="–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ"),
         BotCommand(command="menu", description="–û—Ç–∫—Ä—ã—Ç—å –º–µ–Ω—é"),
         BotCommand(command="version", description="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤–µ—Ä—Å–∏—é")],
        scope=BotCommandScopeDefault(), language_code="ru",
    )
    await bot.set_my_commands(
        [BotCommand(command="start", description="Greeting"),
         BotCommand(command="menu", description="Open menu"),
         BotCommand(command="version", description="Check version")],
        scope=BotCommandScopeDefault(), language_code="en",
    )
    await bot.set_my_commands(
        [BotCommand(command="start", description="◊ë◊®◊õ◊î"),
         BotCommand(command="menu", description="◊§◊™◊ó ◊™◊§◊®◊ô◊ò"),
         BotCommand(command="version", description="◊ë◊ì◊ô◊ß◊™ ◊í◊®◊°◊î")],
        scope=BotCommandScopeDefault(), language_code="he",
    )

# =========================
# Handlers
# =========================
@router.message(CommandStart())
async def on_start(message: Message):
    uid = message.from_user.id
    kb = make_reply_menu_button(user_ui_lang[uid])
    text = {"ru": "–ü—Ä–∏–≤–µ—Ç! –Ø SmartPro 24/7. –ù–∞–∂–º–∏—Ç–µ ¬´–ú–µ–Ω—é¬ª, –∫–æ–≥–¥–∞ –Ω—É–∂–Ω–æ –æ—Ç–∫—Ä—ã—Ç—å –¥–µ–π—Å—Ç–≤–∏—è.",
            "en": "Hi! I‚Äôm SmartPro 24/7. Tap ‚ÄúMenu‚Äù when you want actions.",
            "he": "◊î◊ô◊ô! ◊ê◊†◊ô SmartPro 24/7. ◊ú◊ó◊¶◊ï \"◊™◊§◊®◊ô◊ò\" ◊õ◊ì◊ô ◊ú◊§◊™◊ï◊ó ◊§◊¢◊ï◊ú◊ï◊™."}[user_ui_lang[uid]]
    await send_clean(message, text, reply_markup=kb)

@router.message(Command("menu"))
async def on_menu_cmd(message: Message):
    uid = message.from_user.id
    await send_clean(message, "–ú–µ–Ω—é –¥–µ–π—Å—Ç–≤–∏–π:", reply_markup=make_inline_menu(user_ui_lang[uid]))

@router.message(Command("version"))
async def on_version_cmd(message: Message):
    await send_clean(message, "UNIVERSAL GPT‚Äë4o ‚Äî HOTFIX#7b‚ÄëU9")

@router.message(F.text.casefold() == "–º–µ–Ω—é")
@router.message(F.text.casefold() == "menu")
async def on_menu_text(message: Message):
    uid = message.from_user.id
    await send_clean(message, "–ú–µ–Ω—é –¥–µ–π—Å—Ç–≤–∏–π:", reply_markup=make_inline_menu(user_ui_lang[uid]))

# ---------- Inline buttons ----------
@router.callback_query(F.data == "help")
async def on_help(cb: CallbackQuery):
    uid = cb.from_user.id
    ui = user_ui_lang[uid]
    await cb.answer("–û—Ç–∫—Ä—ã–≤–∞—é –ø–æ–º–æ—â—å‚Ä¶", show_alert=False)
    text = {
        "ru": "–Ø —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫. –ü—Ä–æ—Å—Ç–æ –∑–∞–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å. –°—Ç–æ—Ä–∏—Å/—Ä–∞—Å—Å–∫–∞–∑ ‚Äî –ø–æ —è–≤–Ω–æ–π –ø—Ä–æ—Å—å–±–µ. –ë–µ–∑ Markdown/–∂–∏—Ä–Ω–æ–≥–æ/–∫—É—Ä—Å–∏–≤–∞/—Å–ø–∏—Å–∫–æ–≤.",
        "en": "Universal assistant. Ask anything. Stories/narratives on explicit request. No markdown/bold/italics/lists.",
        "he": "◊¢◊ï◊ñ◊® ◊ê◊ï◊†◊ô◊ë◊®◊°◊ú◊ô. ◊ê◊§◊©◊® ◊ú◊©◊ê◊ï◊ú ◊î◊õ◊ú. ◊°◊ò◊ï◊®◊ô◊ñ/◊°◊ô◊§◊ï◊® ◊®◊ß ◊ë◊ë◊ß◊©◊î ◊û◊§◊ï◊®◊©◊™. ◊ë◊ú◊ô Markdown/◊î◊ì◊í◊©◊ï◊™/◊®◊©◊ô◊û◊ï◊™.",
    }.get(ui, "–Ø —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫. –ü—Ä–æ—Å—Ç–æ –∑–∞–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å.")
    await send_clean(cb.message, text)

@router.callback_query(F.data == "pay")
async def on_pay(cb: CallbackQuery):
    await cb.answer("–û–ø–ª–∞—Ç–∞ —Å–∫–æ—Ä–æ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–∞", show_alert=False)
    await send_clean(cb.message, "–û–ø–ª–∞—Ç–∞ –ø–æ—è–≤–∏—Ç—Å—è –ø–æ–∑–∂–µ (Stripe Checkout).")

@router.callback_query(F.data == "refs")
async def on_refs(cb: CallbackQuery):
    await cb.answer("–†–µ—Ñ–µ—Ä–∞–ª—ã", show_alert=False)
    await send_clean(cb.message, "–†–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–µ —Å—Å—ã–ª–∫–∏ –ø–æ—è–≤—è—Ç—Å—è –ø–æ–∑–∂–µ. –§–æ—Ä–º–∞—Ç: t.me/<bot>?start=ref_<uid>.")

@router.callback_query(F.data == "profile")
async def on_profile(cb: CallbackQuery):
    await cb.answer("–ü—Ä–æ—Ñ–∏–ª—å", show_alert=False)
    user = cb.from_user
    await send_clean(cb.message, f"–ü—Ä–æ—Ñ–∏–ª—å: {user.first_name or ''} {user.last_name or ''}".strip())

@router.callback_query(F.data == "lang")
async def on_change_lang(cb: CallbackQuery):
    uid = cb.from_user.id
    cur = user_ui_lang[uid]
    cycle = {"ru": "en", "en": "he", "he": "ru"}
    user_ui_lang[uid] = cycle.get(cur, "en")
    await cb.answer(f"UI —è–∑—ã–∫: {user_ui_lang[uid].upper()}")
    await send_clean(cb.message, "–Ø–∑—ã–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –∏–∑–º–µ–Ω—ë–Ω.", reply_markup=make_reply_menu_button(user_ui_lang[uid]))

@router.callback_query(F.data == "mode")
async def on_mode(cb: CallbackQuery):
    await cb.answer("–†–µ–∂–∏–º –æ—Ç–≤–µ—Ç–∞", show_alert=False)
    await send_clean(cb.message, "–†–µ–∂–∏–º –æ—Ç–≤–µ—Ç–∞: —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π. –¢–≤–æ—Ä—á–µ—Å—Ç–≤–æ ‚Äî –ø–æ —è–≤–Ω–æ–π –ø—Ä–æ—Å—å–±–µ.")

@router.callback_query(F.data == "tts")
async def on_tts(cb: CallbackQuery):
    await cb.answer("TTS", show_alert=False)
    await send_clean(cb.message, "–û–∑–≤—É—á–∫–∞ (TTS) –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–∞ –ø–æ –∫–Ω–æ–ø–∫–µ, –∫–æ–≥–¥–∞ –ø–æ–¥–∫–ª—é—á–∏–º –¥–≤–∏–∂–æ–∫.")

@router.callback_query(F.data == "asr")
async def on_show_transcript(cb: CallbackQuery):
    await cb.answer("–ü–æ–∫–∞–∑–∞—Ç—å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫—É", show_alert=False)
    await send_clean(cb.message, "–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–∞ –ø–æ—Å–ª–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è ASR (Whisper/gpt‚Äë4o‚Äëmini‚Äëtranscribe).")

@router.callback_query(F.data == "close_menu")
async def on_close_menu(cb: CallbackQuery):
    try:
        await cb.message.edit_reply_markup(reply_markup=None)
    except Exception:
        pass
    await cb.answer("–°–∫—Ä—ã—Ç–æ")

@router.callback_query()
async def on_any_callback(cb: CallbackQuery):
    await cb.answer("–ì–æ—Ç–æ–≤–æ", show_alert=False)

# ---------- Voice / Photo ----------
@router.message(F.voice)
async def on_voice(message: Message):
    uid = message.from_user.id
    ui_lang = user_ui_lang[uid]
    recent_voice_meta[uid]["last_ts"] = time.time()
    text = anti_echo_reply(ui_lang)
    ik = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text={"ru": "–ü–æ–∫–∞–∑–∞—Ç—å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫—É", "en": "Show transcript", "he": "◊î◊¶◊í ◊™◊û◊ú◊ô◊ú"}[ui_lang],
                              callback_data="asr")],
        [InlineKeyboardButton(text={"ru": "–°–∫—Ä—ã—Ç—å", "en": "Close", "he": "◊°◊í◊ï◊®"}[ui_lang],
                              callback_data="close_menu")],
    ])
    await send_clean(message, text, reply_markup=ik)

@router.message(F.photo)
async def on_photo(message: Message):
    await send_clean(message, "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ–ª—É—á–µ–Ω–æ. OCR –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω —á–µ—Ä–µ–∑ –º–µ–Ω—é –ø–æ—Å–ª–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è. –ü–æ–∫–∞ —è –æ—Ç–≤–µ—á—É –ø–æ —Ç–µ–∫—Å—Ç—É.")

# =========================
# Text handler
# =========================
@router.message()
async def on_text(message: Message):
    uid = message.from_user.id
    ui = user_ui_lang[uid]
    text = (message.text or "").strip()
    content_lang = choose_content_lang(uid, text)

    # 1) –°–¢–û–†–ò–° ‚Äî —è–≤–Ω–∞—è –ø—Ä–æ—Å—å–±–∞ (–¥–æ–ø—É—Å–∫–∞–µ–º —Å–ª–æ–≤–∞ –º–µ–∂–¥—É)
    if STORY_TRIG.match(text):
        topic = extract_topic_after_keyword(text, ["—Å—Ç–æ—Ä–∏—Å", "story", "–∏–Ω—Å—Ç–∞-—Å—Ç–æ—Ä–∏—Å", "–∏–Ω—Å—Ç–∞ —Å—Ç–æ—Ä–∏—Å"])
        sys = ("You are a world‚Äëclass creative writer crafting cinematic, sensory Instagram‚Äëstyle stories. "
               f"Answer strictly in { 'Russian' if content_lang=='ru' else ('Hebrew' if content_lang=='he' else 'English') }. "
               "No Markdown, no asterisks/lists/headings.")
        prompt = (f"–¢–µ–º–∞ —Å—Ç–æ—Ä–∏—Å: {topic}\n"
                  f"–ù–∞–ø–∏—à–∏ 6‚Äì8 –∫–∏–Ω–µ–º–∞—Ç–æ–≥—Ä–∞—Ñ–∏—á–Ω—ã—Ö –∫–∞–¥—Ä–æ–≤ (1‚Äì2 –Ω–∞—Å—ã—â–µ–Ω–Ω—ã–µ —Ñ—Ä–∞–∑—ã –Ω–∞ –∫–∞–¥—Ä) —Å–æ –∑–≤—É–∫–∞–º–∏/–∑–∞–ø–∞—Ö–∞–º–∏/—Ç–∞–∫—Ç–∏–ª—å–Ω–æ—Å—Ç—å—é, "
                  f"—Ç–æ—á–Ω—ã–º–∏ –Ω–∞–±–ª—é–¥–µ–Ω–∏—è–º–∏ –∏ —Å–∏–ª—å–Ω–æ–π –∫–æ–Ω—Ü–æ–≤–∫–æ–π. –ü–∏—à–∏ –Ω–∞ ({content_lang}). –ë–µ–∑ –≤—Å—Ç—É–ø–∏—Ç–µ–ª—å–Ω—ã—Ö —Ñ—Ä–∞–∑ –∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π.")
        ans = await ask_openai(prompt, system=sys, temperature=0.9, model="gpt-4o")
        return await send_clean(message, ans)

    # 2) –†–∞—Å—Å–∫–∞–∑/—ç—Å—Å–µ ‚Äî —è–≤–Ω–∞—è –ø—Ä–æ—Å—å–±–∞
    if NARR_TRIG.match(text):
        topic = extract_topic_after_keyword(text, ["—Ä–∞—Å—Å–∫–∞–∑", "—ç—Å—Å–µ", "—Å–æ—á–∏–Ω–µ–Ω–∏–µ", "–ø–æ–≤–µ—Å—Ç—å", "short story", "essay"])
        sys = ("You are a literary writer. Produce a vivid short narrative. "
               f"Answer strictly in { 'Russian' if content_lang=='ru' else ('Hebrew' if content_lang=='he' else 'English') }. "
               "No Markdown, no asterisks/lists/headings.")
        prompt = (f"–¢–µ–º–∞ —Ä–∞—Å—Å–∫–∞–∑–∞: {topic}\n"
                  f"–ù–∞–ø–∏—à–∏ –∫–æ—Ä–æ—Ç–∫–∏–π —Ä–∞—Å—Å–∫–∞–∑ 350‚Äì600 —Å–ª–æ–≤ –Ω–∞ ({content_lang}), —Å –æ–±—Ä–∞–∑–Ω–æ—Å—Ç—å—é, —Ä–∏—Ç–º–æ–º, —Å—Ü–µ–Ω–∞–º–∏, –¥–∏–∞–ª–æ–≥–∞–º–∏ –ø–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏. "
                  f"–ë–µ–∑ –∫–ª–∏—à–µ –∏ –±–µ–∑ –æ–±—ä—è—Å–Ω–µ–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç–∞.")
        ans = await ask_openai(prompt, system=sys, temperature=0.8, model="gpt-4o")
        return await send_clean(message, ans)

    # 3) –ö–æ–ø–∏—Ä–∞–π—Ç (–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ/–±–∏–æ/–æ–ø–∏—Å–∞–Ω–∏–µ)
    if COPY_TRIG.search(text):
        m = re.search(r'–º–µ–Ω—è –∑–æ–≤—É—Ç\s+([A-Za-z–ê-–Ø–∞-—è–Å—ë\-]+)', text, re.IGNORECASE)
        tg_name = (message.from_user.first_name or "").strip() if message.from_user else ""
        name = m.group(1) if m else tg_name
        sys = copy_system_prompt_for(content_lang)
        prompt = (f"–ù–∞–ø–∏—à–∏ –ø–æ—Å—Ç-–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –≤ –ø–µ—Ä–≤–æ–º –ª–∏—Ü–µ –Ω–∞ ({content_lang}). "
                  f"–ï—Å–ª–∏ –∏–º—è –¥–æ—Å—Ç—É–ø–Ω–æ, –∏—Å–ø–æ–ª—å–∑—É–π –µ–≥–æ: {name if name else '–∏–º—è –Ω–µ —É–∫–∞–∑–∞–Ω–æ'}. "
                  f"–°—É—Ç—å –∏–∑ –∑–∞–ø—Ä–æ—Å–∞: {text}. –ò–∑–±–µ–≥–∞–π –∫–ª–∏—à–µ –∏ —à–∞–±–ª–æ–Ω–æ–≤, –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–π —Å–ø–∏—Å–∫–∏ –∏ –∑–∞–≥–æ–ª–æ–≤–∫–∏.")
        ans = await ask_openai(prompt, system=sys, temperature=0.65)
        return await send_clean(message, ans)

    # 4) –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é ‚Äî —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç
    sys = system_prompt_for(content_lang)
    prompt = build_user_prompt(content_lang, text)
    ans = await ask_openai(prompt, system=sys, temperature=0.55)
    return await send_clean(message, ans)

# =========================
# FastAPI routes
# =========================
@app.get("/version", response_class=PlainTextResponse)
async def version():
    return "UNIVERSAL GPT‚Äë4o ‚Äî HOTFIX#7b‚ÄëU9"

@app.post(WEBHOOK_PATH)
async def tg_webhook(request: Request):
    secret = request.headers.get("X-Telegram-Bot-Api-Secret-Token")
    if secret != WEBHOOK_SECRET:
        raise HTTPException(status_code=403, detail="Invalid secret")
    data = await request.json()
    update = Update.model_validate(data)
    await dp.feed_update(bot, update)
    return JSONResponse({"ok": True})

@app.get("/healthz", response_class=PlainTextResponse)
async def healthz():
    return "ok"

@app.on_event("startup")
async def on_startup():
    try:
        await bot.delete_webhook(drop_pending_updates=True)
    except Exception:
        pass
    await set_commands()
    if BASE_URL and TELEGRAM_BOT_TOKEN:
        try:
            await bot.set_webhook(url=BASE_URL + WEBHOOK_PATH, secret_token=WEBHOOK_SECRET, drop_pending_updates=True)
        except Exception:
            pass

# Start: uvicorn bot:app --host 0.0.0.0 --port 8080
